{
  int i; int j; float[100] a; float v; float x;
  while (true) {
    do i = i+1; while (a[i] < v);
    do j = j-1; while (a[j] > v);
    if (i >= j) break;
    x = a[i]; a[i] = a[j]; a[j] = x;
  }
}

/***** result ******/ 
// 1:     i = i + 1            ----\      do-while
// 2:     t1 = a [ i ]              >     /     \
// 3:     if t1 < v goto 1     ----/    body     >
// 4:     j = j - 1                       |     / \
// 5:     t2 = a [ j ]                assign  []   v
// 6:     if t2 > v goto 4           /   \    | \
// 7:     ifFalse i >= j goto 9     i     +   a  i
// 8:     goto 14                        / \
// 9:     x = a [ i ]                   i   1
// 10:    t3 = a [ j ]
// 11:    a [ i ] = t3
// 12:    a [ j ] = x
// 13:    goto 1
// 14:

// context free grammmar
if (expression) statement else statement  /* can be expressed as */
// stmt -> if (expr) stmt else stmt
// ^-- Such a rule is called a PRODUCTION. In a production, LEXICAL ELS like the
// keyword if and the parentheses are called TERMINALS. Vars like \expr and
// \stmt represent seqs of terminals and are called NONTERMINALS

// A CONTEXT-FREE GRAMMAR has four components:
// 1. A set of TERMINAL symbols, sometimes referred to as "tokens." The termi-­
// nals are the elementary symbols of the language defined by the grammar.
// 2. A set of nonterminals, sometimes called "syntactic variables." Each non­
// terminal represents a set of strings of terminals, in a manner we shall
// describe.
// 3. A set of productions, where each production consists of a NONTERMINAL,
// called the HEAD or LEFT SIDE of the production, an arrow, and a sequence of
// terminals and/or nonterminals, called the BODY or RIGHT SIDE of the produc­
// tion. The intuitive intent of a production is to specify one of the written
// forms of a construct; if the head nonterminal represents a construct, then
// the body represents a written form of the construct.
// 4. A designation of one of the nonterminals as the start symbol.

// Tokens vs Terminals

// terminals:   + - 0 1 2 3 4 5 6 7 8 9 ; nonterminal: list digit
list -> list + digit | list - digit | digit             /* (2.1) */
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
// We say a production is for a nonterminal if the nonterminal is the head of
// the production. A string of terminals is a seq of zero or more terminals.
// The string of zero terminals, written as ϵ, is called the empty string

// DERIVATIONS
// A grammar DERIVES strings by beginning with the start symbol and repeatedly
// replacing a nonterminal by the body of a production for that nonterminal. The
// terminal strings that can be derived from the start symbol form the LANGUAGE
// defined by the grammar

// Grammar for list of parameters in a function call.
call        -> ID ( optparams )
optparams   -> params | ϵ
params      -> params, param | param
// We have not shown the productions for param, since parameters are really 
// arbitrary exprs. Shortly, we shall discuss the appropriate productions
// for the various language constructs, such as exprs, statements, and so on

// PARSING is the problem of taking a string of terminals and figuring out how
// to derive it from the start symbol of the grammar, and if it cannot be
// derived from the start symbol of the grammar, then reporting syntax errors
// within the string.
// The PARSE TREE pictorially shows how the start symbol of a grammar derives a
// string in the lang. If nonterminal A has a production A -> XYZ, then
//        A
//      / | \
//     X  Y  Z
// Formally, given a context-free grammar, a parse tree according to the grammar
// is a tree with the following properties:
// 1. The root is labeled by the start symbol.
// 2. Each leaf is labeled by a terminal or by ϵ.
// 3. Each interior node is labeled by a nonterminal.
// 4. If A is the nonterminal labeling some interior node and X1,X2..,Xn are
// the labels of the children of that node from left to right, then there must
// be a production A -> X1X2...Xn. Here, X1,X2...Xn each stand for a symbol that
// is either a terminal or a nonterminal. As a special case, if A -> ϵ is a
// production, then a node labeled A may have a single child labeled ϵ.
//
// Tree terminology p69

// Each node in the tree is labeled by a grammar symbol. An interior node and
// its children correspond to a production; the interior node corresponds to the
// head of the production, the children to the body.
//          list ----- list -\
//         / | \        |     \- digit
//    list   |  digit   |         |
//     |     |    |     |         |
//     9     -    5     +         2
//
// Another definition of the language generated by a grammar is as the set of
// strings that can be generated by some parse tree. The process of finding a 
// parse tree for a given string of terminals is called PARSING that string.

// We have to be careful in talking about the structure of a string according to
// a grammar. A grammar can have more than one parse tree generating a given
// string of terminals. Such a grammar is said to be AMBIGUOUS. To show that a
// grammar is ambiguous, all we need to do is find a terminal string that is the
// yield of more than one parse tree. We need to design unambiguous grammars
// for compiling applications, or to use ambiguous grammars with additional
// rules to resolve the ambiguities.

// we used a single nontertninal string and did not dis­ tinguish between digits 
str -> str + str | str - str | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 // and list
// so, 9-5+2, can be parsed as (9-5)+2 or 9-(5+2), in (2.1) it's impossible

// ^^^^----- p70

// Strings like a=b=c with a right-associative operator are generated by the
right   -> LETTER = right | LETTER                        // following 'grammar
letter  -> a | b .. | z
// Note that the parse tree for 9-5-2 grows down towards the left, whereas the
// parse tree for a=b=c grows down towards the right.

// Precedence
left-associative: + -
left-associative: * /

factor -> DIGIT | (expr)
term -> term * factor | term / factor | factor
expr -> expr + term   | expr - term   | term
// ^-- generalization of grammar p73
// from me: expr, term just denote level of recursion, expr 0, term 1, factor >1

stmt  -> ID = expression;     // id represents any identifier
       | IF (expression) stmt
       | IF (expression) stmt ELSE stmt
       | WHILE (expression) stmt
       | DO stmt WHILE (expression) ;
       | { stmts }
stmts -> stmts stmt | ϵ
// ^-- The productions for expression are not shown. The assignment statements
// specified by the first production are legal in Java, although Java treats = as 
// an assignment operator that can appear within an expression. [exmp] Java
// allows a = b = c, which this grammar does not.

digit   -> 0..9 | ID
signed  -> - digit | + digit
factor  -> signed | (expr)
term    -> term * factor | term / factor | factor
expr    -> expr + term | expr - term | term
