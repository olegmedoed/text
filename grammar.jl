@1
# Let's start with the formal definition of grammar. A grammar is a precise
# description of a formal language, ie., it describes what possible sequence
# of symbols/strings constitute valid words or sentences in that language,
# but doesn't describe their semantics. 

# A grammar G <N, Σ ,P, S> consists of the following components:
# 1. A finite set N of non terminal symbols or variables.
# 2. A finite set Σ of terminal symbols that are disjoint from N.
# 3. A finite set P of production rules of the form 
#   (Σ U N)* N (Σ U N)* -> (Σ U N)* where * is the Kleene star operator and U 
#   denotes the set union. Each production rule maps from one string of symbs to
#   another where the left hand side contains at least one non terminal symbol.
# 4. A distinguished start symbol S ∈ N.
# A language is said to be a regular language if it is generated by a regular
# grammar. A grammar is said to be regular if it's either right-linear or
# left-linear. 
# Specifically, a grammar  G <N, Σ ,P, S> is said to be right-linear if each
# of its production rules is either of the form A -> xB or of the form A -> x,
# where A and B are non terminal symbols in N and x is a string of terminal 
# symbols in Σ*. Similarly, it is left-linear if each of its production rules
# is either of the form A -> Bx or of the form A -> x, where A and B are non
# terminal symbols in N and x is a string of terminal symbols in Σ*.

# A language is said to be context-free if it is generated by a context-free
# grammar. A grammar G <N, Σ, P, S> is context-free if the production rules are
# of the form N -> (N U Σ)*.

# Unlike regular grammars, the right hand side of the production rules in
# context free grammars are unrestricted and can be any combination of terminals
# and non terminals. Regular languages are subsets of context free languages.


@2
# SSA(static single assignment form) requires that each var is assigned exactly
# once, and every var is defined before it is used. Existing variables in the
# original IR are split into versions, new variables typically indicated by
# the original name with a subscript in textbooks, so that every definition
# gets its own version. In SSA form, use-def chains are explicit and each
# contains a single element.
# SSA is formally equivalent to a well-behaved subset of CPS(continuation-
# passing style) excluding non-local control flow, which does not occur when
# CPS is used as intermediate representation
