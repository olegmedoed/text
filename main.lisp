;;; ACDE  -  abstract compund data entity
;;; AIWE  -  as I wrote earlier

;;;;  As Fred Brooks observed in The Mythical Man-Month,
;;;;       "Representation is the essence of programming."

; такая важная деталь компилятора, как алгоритм выделения регистров под
; временные переменные - это ни что иное как классическая задача раскраски 
; циклического ненаправленного графа в минимальное количество цветов.

; (08-feb-16)
; Whereas in Rust,Hskl we can be sure that programm work mostly correctly since
; the `powerful static analizer` of this langs guaranty us many invariants(and
; we can express this invariants due to type-system(lifetimes in Rust)), ..
; in Lisp we can be sure that largest part of programm is worked correctly since
; it's generated by macroses. The bigger amount of the `our programm` we can
; write through (only one time) written macrosses, the more reliable our
; programm, since well-defined macro always write code correctly - as opposed to
; programmer. Also the shorter our programm, the easily we can find a bag.

0
;----from Wiki: about bottom-up design
;In a bottom-up approach, the individual base elements of the system are first
;specified in great detail. These elements are then linked together to form
;larger subsystems, which then in turn are linked, sometimes in many levels,
;until a complete top-level system is formed. This strategy often resembles a
;"seed" model, whereby the beginnings are small, but eventually grow in
;complexity and completeness. Object-oriented programming (OOP) is a paradigm
;that uses "objects" to design applications and computer programs.
;
;----from stackoverflow:
;1  In "On LISP", Paul Graham uses the term "bottom-up" slightly differently to 
;mean continually extracting common functionality into shared functions so that
;you end up creating a new, higher level dialect of LISP that lets you program
;in terms of your application domain. That's not a common use of the term. These
;days we would call that "refactoring" and "embedded Domain-Specific Languages"
;2  It refers to a style of programming where an application is constructed 
;starting with existing primitives of the programming language, and constructing
;gradually more and more complicated features, until the all of the application
;has been written.
;
;-[from.me] P.Graham bottom up style is: (28-jan-16)
;  the idea of for set of `utilities` what become so ubiquty in programm that
;  form like `new lang` (exmp of such utility in `C` is `for(;;){}` loop,
;  actually it can be written by `while`, but since it very convenient to use
;  such pattern it's embedded in lang, in Lisp we use `macros` for this purposes,
;  [BTW, `do`-loop in Lisp it just macro]). So, macrosses and `utilities`(
;  general.func/func.generators) form our new eDSL.
;  Like in TDD(as R.Zol said) we write what functionality we need(test),
;  implement this functionality, and `refactor` our code to be more extensible
;  (pluggable) by trying make our classes more general and find common pattern
;  in our code to form more general funcs, what we use like `lang` constructions;  
;   exmp: `validates :name, :capitalize, :other_validator` is like embedded in
;   language construction(in C++ we need committee revised the standard) what
;   extends our class, that let us write code in more declarative way, more
;   faster and less `errorpronessly`(since we just write what we want, and not
;   how to do it[the author of macro/utility has cared about it])
;   ...
;   {BUT: OF COURSE IF YOU DON'T KNOW HOW ALL THIS MAGIC WORKS, IT BECOMES
;    UNCFORTABLE ... SO
;;;     ... ONLY "UBIQUITOUS PATTERNs" should be caputred in "higher-ordered fns"
;;;         and macroses }
;
; Tl;DR (mar-16)
; programs writes programs, the correctness of programm depends of correctness
; programm generator(macro, high-ord func)


5
; HERE was func from StOver how add lists in O(1) [keep tail accesible]
; P.S.aft2m
;why it has no matter?
;- in lisp is used for prototyping, and superseded by more suited data-types
;  in future(arrays, hash-tables ...)
;- list is  used for determining process control.flow sometimes

31
;so, Why Lisp-list is good to represent computation tree, and ,as I noticed, its
;nodes has no vals(only branches), so only leaves have vals(axioms|base).
;That since, this vals is computed on 'combine' step in div-n-conc algo(or
;linear-ingeniring style[that is the same])

32
;@ I understand how to use lists on prototype.stage in Lisp.
;It since initially you don't know how your data will looks like(or be
;better.approrpate form performance perspective), so you implement all as list,
;and @@@ hadle this list by using some meths, what form the API of the ACDE
;which this list is represent.  So,  in wumpus.lisp, meth: 'get-connected' use
;'edge-list' obj that initially was represented as list, but in future we
;replace it with hash, BUT, it's stupid code, we should not to write new
;'get-connecter-hash' to handle 'edge-list' in new representation(hash), we just
;shoud handel 'edge-list' with ACDE-API conform to 'edge-list', but not
;representation dependent meths(member, gethash..)
    BL9T' .. JS:
module.exports = {
    data...
    methdos...
}
here RAW-obj plays the same role as 'list' in this (proto.stage) case.

